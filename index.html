<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Stereo Rendering</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 90%;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        h1 {
            margin: 0 0 15px 0;
            font-size: 1.8em;
        }
        
        p {
            margin: 0 0 25px 0;
            opacity: 0.9;
            line-height: 1.5;
        }
        
        button {
            background: white;
            color: #667eea;
            border: none;
            padding: 18px 45px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 20px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            font-size: 15px;
        }
        
        .version {
            margin-top: 15px;
            font-size: 12px;
            opacity: 0.7;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ü•Ω –ë–∏–Ω–æ–∫—É–ª—è—Ä–Ω—ã–π MVP</h1>
        <p>
            –¢—Ä–µ–Ω–∞–∂—ë—Ä ¬´–°–æ–≤–º–µ—Å—Ç–∏ —Ç–æ—á–∫–∏¬ª (dichoptic alignment)<br>
            –°—Ç–∏–∫: –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ ‚Äî —Å–º–µ—â–µ–Ω–∏–µ, –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑ ‚Äî –¥–∏—Å—Ç–∞–Ω—Ü–∏—è<br>
            –¢—Ä–∏–≥–≥–µ—Ä: –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å
        </p>
        <button id="startBtn" onclick="startXR()">–ó–∞–ø—É—Å—Ç–∏—Ç—å VR</button>
        <div id="status">–ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø—É—Å–∫—É</div>
        <div class="version">v0.3 (2025-12-29) - MVP alignment</div>
    </div>
    
    <canvas id="glCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let stimulusGroup;
        let crosshair;

        // –°—Ç–∏–º—É–ª—ã (—Ä–∞–∑–Ω—ã–µ —Ä–µ–∂–∏–º—ã)
        let leftRing;
        let rightDot;
        let rightGuideRing;
        let leftHalfDisk;
        let rightHalfDisk;
        let leftZigSplit;
        let rightZigSplit;

        // HUD (–æ–¥–Ω–∞ –ø–∞–Ω–µ–ª—å)
        let hudPanel;
        let hudLastText = '';
        let hudLastBg = '';
        let hudLastUpdateAtMs = 0;
        let xrSession = null;
        let frameCount = 0;
        let debugInfo = { leftEye: 'unknown', rightEye: 'unknown', viewCount: 0 };

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞
        let targetDistance = 2.0; // –º–µ—Ç—Ä—ã –¥–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Å—Ç–∏–º—É–ª–æ–≤
        let targetHeight = 1.6; // –≤—ã—Å–æ—Ç–∞ —Å—Ç–∏–º—É–ª–∞ (—Å–∏–¥—è/—Å—Ç–æ—è)
        let disparityX = 0.25; // —Ç–µ–∫—É—â–µ–µ —Å–º–µ—â–µ–Ω–∏–µ (–º)
        let tolerance = 0.015; // –ø–æ—Ä–æ–≥ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è (–º)
        let score = 0;
        let trials = 0;
        let lastTimeMs = 0;
        let lastSelectAtMs = -1e9;

        const MODES = ['alignment', 'split'];
        let modeIndex = 0;

        const SPLIT_SHAPES = ['vertical', 'horizontal', 'zigzag'];
        let splitShapeIndex = 0;

        let pulseEnabled = false;
        const PULSE_PERIODS = [0.6, 1.0, 1.6, 2.4];
        let pulsePeriodIndex = 1;
        
        const canvas = document.getElementById('glCanvas');
        const startBtn = document.getElementById('startBtn');
        const statusDiv = document.getElementById('status');
        const container = document.getElementById('container');
        
        function log(msg) {
            console.log(msg);
            statusDiv.textContent = msg;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ WebXR
        if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                if (supported) {
                    log('‚úÖ WebXR –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                } else {
                    log('‚ùå VR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                    startBtn.disabled = true;
                }
            }).catch(err => {
                log('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: ' + err.message);
                startBtn.disabled = true;
            });
        } else {
            log('‚ùå WebXR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
            startBtn.disabled = true;
        }
        
        function createTextTexture(message, backgroundColor) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 512;

            const lines = String(message).split(/\r?\n/);

            // –§–æ–Ω
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);

            // –ö–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ã–π —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ (–µ—Å–ª–∏ —Ñ–æ–Ω –±–µ–ª—ã–π ‚Äî —Ä–∏—Å—É–µ–º —á—ë—Ä–Ω—ã–º)
            const bg = String(backgroundColor).toLowerCase();
            const textColor = (bg === '#fff' || bg === '#ffffff' || bg === 'white') ? '#000000' : '#ffffff';

            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = textColor;

            // –ü–æ–¥–±–∏—Ä–∞–µ–º —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞, —á—Ç–æ–±—ã –≤–ª–µ–∑–ª–∞ —Å–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
            const maxTextWidth = canvas.width - 40;
            let fontSize = 64;
            while (fontSize >= 22) {
                context.font = `Bold ${fontSize}px Arial`;
                const widest = lines.reduce((m, line) => Math.max(m, context.measureText(line).width), 0);
                if (widest <= maxTextWidth) break;
                fontSize -= 2;
            }

            const lineHeight = Math.round(fontSize * 1.1);
            const totalHeight = lineHeight * lines.length;
            const startY = (canvas.height - totalHeight) / 2 + lineHeight / 2;

            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createHudPanel(message, backgroundColor) {
            const texture = createTextTexture(message, backgroundColor);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            material.depthTest = false;
            const geometry = new THREE.PlaneGeometry(1.60, 0.70);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.renderOrder = 999;
            mesh.layers.set(1);
            mesh.layers.enable(2); // –≤–∏–¥–Ω–æ –æ–±–æ–∏–º–∏ –≥–ª–∞–∑–∞–º–∏
            return mesh;
        }

        function updateHudPanel(mesh, message, backgroundColor) {
            if (!mesh || !mesh.material) return;
            if (message === hudLastText && backgroundColor === hudLastBg) return;
            const oldMap = mesh.material.map;
            mesh.material.map = createTextTexture(message, backgroundColor);
            mesh.material.needsUpdate = true;
            if (oldMap) oldMap.dispose();
            hudLastText = message;
            hudLastBg = backgroundColor;
        }

        function clamp(v, min, max) {
            return Math.min(max, Math.max(min, v));
        }

        function deadzone(v, dz) {
            return Math.abs(v) < dz ? 0 : v;
        }

        function randomizeTrial() {
            const mag = 0.08 + Math.random() * 0.30;
            const sign = Math.random() < 0.5 ? -1 : 1;
            disparityX = mag * sign;
            trials++;
        }

        function currentMode() {
            return MODES[modeIndex] || 'alignment';
        }

        function pulsePeriodSeconds() {
            return PULSE_PERIODS[pulsePeriodIndex] || 1.0;
        }

        function currentSplitShape() {
            return SPLIT_SHAPES[splitShapeIndex] || 'vertical';
        }

        function easeOutCubic(t) {
            const x = clamp(t, 0, 1);
            return 1 - Math.pow(1 - x, 3);
        }

        function applyModeVisibility() {
            const mode = currentMode();
            if (leftRing) leftRing.visible = mode === 'alignment';
            if (rightDot) rightDot.visible = mode === 'alignment';
            if (rightGuideRing) rightGuideRing.visible = mode === 'alignment';

            const splitShape = currentSplitShape();
            const useZig = mode === 'split' && splitShape === 'zigzag';
            if (leftHalfDisk) leftHalfDisk.visible = mode === 'split' && !useZig;
            if (rightHalfDisk) rightHalfDisk.visible = mode === 'split' && !useZig;
            if (leftZigSplit) leftZigSplit.visible = useZig;
            if (rightZigSplit) rightZigSplit.visible = useZig;
        }

        function createZigzagSplitTexture(side, outerRadius, innerRadius) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, size, size);
            ctx.translate(size / 2, size / 2);
            const pxPerUnit = (size * 0.48) / outerRadius;
            ctx.scale(pxPerUnit, pxPerUnit);

            // –ë–∞–∑–æ–≤–∞—è —Ñ–∏–≥—É—Ä–∞: –¥–∏—Å–∫ –∏–ª–∏ –∫–æ–ª—å—Ü–æ
            ctx.fillStyle = '#ff4d4d';
            ctx.beginPath();
            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2, false);
            if (innerRadius > 0.0001) {
                ctx.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
                ctx.fill('evenodd');
            } else {
                ctx.fill();
            }

            // –ú–∞—Å–∫–∞ –ø–æ–ª–æ–≤–∏–Ω—ã —Å –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω–æ–π –≥—Ä–∞–Ω–∏—Ü–µ–π
            ctx.globalCompositeOperation = 'destination-in';
            const big = outerRadius * 3;
            const amp = outerRadius * 0.12;
            const teeth = 10;
            const boundary = [];
            for (let i = 0; i <= teeth; i++) {
                const y = -outerRadius + (2 * outerRadius * i) / teeth;
                const x = i % 2 === 0 ? amp : -amp;
                boundary.push({ x, y });
            }

            ctx.beginPath();
            if (side === 'left') {
                ctx.moveTo(-big, -big);
                ctx.lineTo(boundary[0].x, boundary[0].y);
                for (let i = 1; i < boundary.length; i++) ctx.lineTo(boundary[i].x, boundary[i].y);
                ctx.lineTo(-big, big);
                ctx.closePath();
            } else {
                ctx.moveTo(big, -big);
                ctx.lineTo(big, big);
                for (let i = boundary.length - 1; i >= 0; i--) ctx.lineTo(boundary[i].x, boundary[i].y);
                ctx.closePath();
            }
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';

            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = false;
            tex.needsUpdate = true;
            return tex;
        }

        function getGamepad(session, handednessPreference) {
            if (!session) return null;
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Å—Ç—Ä–æ–≥–æ –ø–æ handedness
            for (const src of session.inputSources) {
                if (!src || !src.gamepad) continue;
                if (src.handedness === handednessPreference) return src.gamepad;
            }
            // –ü–æ—Ç–æ–º "none" –∏–ª–∏ –ª—é–±–æ–π
            for (const src of session.inputSources) {
                if (!src || !src.gamepad) continue;
                if (src.handedness === 'none') return src.gamepad;
            }
            for (const src of session.inputSources) {
                if (!src || !src.gamepad) continue;
                return src.gamepad;
            }
            return null;
        }

        function buttonPressed(gamepad, index) {
            const b = gamepad?.buttons?.[index];
            return !!(b && (b.pressed || b.value > 0.8));
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
        function initThreeJS() {
            log('üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js...');
            
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 0);
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(2, 3, 2);
            scene.add(light1);

            stimulusGroup = new THREE.Group();
            scene.add(stimulusGroup);

            // –ö—Ä–µ—Å—Ç —Ñ–∏–∫—Å–∞—Ü–∏–∏ (–≤–∏–¥–µ–Ω –æ–±–æ–∏–º–∏ –≥–ª–∞–∑–∞–º–∏)
            crosshair = new THREE.Group();
            crosshair.layers.set(0);
            const chMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const chH = new THREE.Mesh(new THREE.BoxGeometry(0.20, 0.01, 0.01), chMat);
            const chV = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.20, 0.01), chMat);
            crosshair.add(chH);
            crosshair.add(chV);
            stimulusGroup.add(crosshair);

            // –†–µ–∂–∏–º alignment: –ª–µ–≤—ã–π –≥–ª–∞–∑ ‚Äî –∫–æ–ª—å—Ü–æ, –ø—Ä–∞–≤—ã–π ‚Äî —Ç–æ—á–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
            const RING_RADIUS = 0.14;
            const RING_TUBE = 0.020;
            const RING_INNER_RADIUS = RING_RADIUS - RING_TUBE;

            const ringMatLeft = new THREE.MeshStandardMaterial({ color: 0xff4d4d, emissive: 0xff0000, emissiveIntensity: 0.25, transparent: true, opacity: 1.0 });
            leftRing = new THREE.Mesh(new THREE.TorusGeometry(RING_RADIUS, RING_TUBE, 12, 64), ringMatLeft);
            leftRing.layers.set(1);
            stimulusGroup.add(leftRing);

            // –ü—Ä–∞–≤—ã–π –≥–ª–∞–∑: –∫—Ä–∞—Å–Ω—ã–π –¥–∏—Å–∫ –¥–∏–∞–º–µ—Ç—Ä–æ–º –∫–∞–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å –∫–æ–ª—å—Ü–∞
            const dotMatRight = new THREE.MeshBasicMaterial({ color: 0xff4d4d, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
            rightDot = new THREE.Mesh(new THREE.CircleGeometry(RING_INNER_RADIUS, 48), dotMatRight);
            rightDot.layers.set(2);
            stimulusGroup.add(rightDot);

            // –í–æ–∫—Ä—É–≥ –¥–∏—Å–∫–∞ ‚Äî —Å–µ—Ä–æ–µ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ–µ –∫–æ–ª—å—Ü–æ (–ø—Ä–∞–≤—ã–π –≥–ª–∞–∑)
            const guideMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.35 });
            rightGuideRing = new THREE.Mesh(new THREE.TorusGeometry(RING_RADIUS, 0.008, 10, 64), guideMat);
            rightGuideRing.layers.set(2);
            stimulusGroup.add(rightGuideRing);

            // –†–µ–∂–∏–º split: –ø–æ–ª–æ–≤–∏–Ω–∫–∏ –¶–ï–õ–¨–ù–û–ì–û –∫—Ä—É–≥–∞ (–Ω–µ –∫–æ–ª—å—Ü–æ)
            const SPLIT_RADIUS = RING_RADIUS;
            const splitMatLeft = new THREE.MeshBasicMaterial({ color: 0xff4d4d, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
            const splitMatRight = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1.0, side: THREE.DoubleSide });

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ä–∞–∑—Ä–µ–∑ (left/right)
            leftHalfDisk = new THREE.Mesh(new THREE.CircleGeometry(SPLIT_RADIUS, 72, Math.PI / 2, Math.PI), splitMatLeft);
            leftHalfDisk.layers.set(1);
            stimulusGroup.add(leftHalfDisk);

            rightHalfDisk = new THREE.Mesh(new THREE.CircleGeometry(SPLIT_RADIUS, 72, -Math.PI / 2, Math.PI), splitMatRight);
            rightHalfDisk.layers.set(2);
            stimulusGroup.add(rightHalfDisk);

            // –†–µ–∂–∏–º split (zigzag): –ø–æ–ª–æ–≤–∏–Ω—ã –¶–ï–õ–¨–ù–û–ì–û –∫—Ä—É–≥–∞ —Å ¬´–∑—É–±—á–∏–∫–∞–º–∏¬ª –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ
            const outer = RING_RADIUS;
            const inner = 0;
            const zigSize = outer * 2 * 1.10;
            const zigGeom = new THREE.PlaneGeometry(zigSize, zigSize);
            const zigLeftTex = createZigzagSplitTexture('left', outer, inner);
            const zigRightTex = createZigzagSplitTexture('right', outer, inner);
            leftZigSplit = new THREE.Mesh(
                zigGeom,
                new THREE.MeshBasicMaterial({ map: zigLeftTex, transparent: true, opacity: 1.0, side: THREE.DoubleSide })
            );
            leftZigSplit.layers.set(1);
            stimulusGroup.add(leftZigSplit);

            rightZigSplit = new THREE.Mesh(
                zigGeom,
                new THREE.MeshBasicMaterial({ map: zigRightTex, transparent: true, opacity: 1.0, side: THREE.DoubleSide })
            );
            rightZigSplit.layers.set(2);
            stimulusGroup.add(rightZigSplit);

            applyModeVisibility();

            // HUD –≤ VR: –æ–¥–Ω–∞ –ø–∞–Ω–µ–ª—å –ø–æ–¥–∞–ª—å—à–µ, –∫—Ä—É–ø–Ω–µ–µ, –±–µ–∑ billboard
            hudPanel = createHudPanel('...', '#222222');
            hudPanel.position.set(0, 2.2, -2.3);
            scene.add(hudPanel);
            
            // –ü–æ–ª
            const floorGeom = new THREE.PlaneGeometry(10, 10);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeom, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);
            
            // –°–µ—Ç–∫–∞
            const grid = new THREE.GridHelper(10, 20, 0x666666, 0x444444);
            grid.position.y = 0.01;
            scene.add(grid);

            // –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã: —Ç—Ä–∏–≥–≥–µ—Ä (select) –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            const controller0 = renderer.xr.getController(0);
            const controller1 = renderer.xr.getController(1);
            const onSelect = () => {
                const now = performance.now();
                // –∞–Ω—Ç–∏–¥—Ä–µ–±–µ–∑–≥
                if (now - lastSelectAtMs < 250) return;
                lastSelectAtMs = now;

                const aligned = Math.abs(disparityX) <= tolerance;
                if (aligned) score++;
                const bg = aligned ? '#1f7a3a' : '#7a1f1f';
                const txt = aligned ? 'OK ‚úÖ  –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥' : '–ù–µ —Å–æ–≤–ø–∞–ª–æ ‚ùå  –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë';
                updateHudPanel(hudPanel, txt, bg);

                // –Ω–æ–≤—ã–π —Ä–∞—É–Ω–¥ (–∏ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ, –∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî —á—Ç–æ–±—ã –±—ã–ª–æ –¥–≤–∏–∂–µ–Ω–∏–µ)
                randomizeTrial();
            };
            controller0.addEventListener('selectstart', onSelect);
            controller1.addEventListener('selectstart', onSelect);
            scene.add(controller0);
            scene.add(controller1);

            randomizeTrial();
            
            log('‚úÖ Three.js –≥–æ—Ç–æ–≤');
        }
        
        // –ó–∞–ø—É—Å–∫ XR
        async function startXR() {
            try {
                log('üöÄ –ó–∞–ø—É—Å–∫ VR...');
                startBtn.disabled = true;
                
                initThreeJS();
                
                xrSession = await navigator.xr.requestSession('immersive-vr', {
                    requiredFeatures: ['local-floor']
                });
                
                log('‚úÖ –°–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞');
                
                await renderer.xr.setSession(xrSession);
                
                container.style.display = 'none';
                
                log('‚úÖ VR –∞–∫—Ç–∏–≤–µ–Ω!');
                
                xrSession.addEventListener('end', () => {
                    log('VR –∑–∞–≤–µ—Ä—à—ë–Ω');
                    container.style.display = 'block';
                    startBtn.disabled = false;
                    xrSession = null;
                    frameCount = 0;
                });
                
                renderer.setAnimationLoop(animate);
                
            } catch (err) {
                log('‚ùå –û—à–∏–±–∫–∞: ' + err.message);
                console.error(err);
                startBtn.disabled = false;
            }
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥
        function animate(time) {
            frameCount++;

            const dt = lastTimeMs ? (time - lastTimeMs) / 1000 : 0;
            lastTimeMs = time;

            // –õ—ë–≥–∫–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –∑–∞–º–µ—Ç–Ω–æ—Å—Ç–∏
            if (leftRing) leftRing.rotation.z = time * 0.0003;
            {
                const splitRot = currentSplitShape() === 'horizontal' ? Math.PI / 2 : 0;
                if (leftHalfDisk) leftHalfDisk.rotation.z = splitRot + time * 0.0003;
                if (rightHalfDisk) rightHalfDisk.rotation.z = splitRot + time * 0.0003;
                if (leftZigSplit) leftZigSplit.rotation.z = time * 0.0003;
                if (rightZigSplit) rightZigSplit.rotation.z = time * 0.0003;
            }

            // –ß—Ç–µ–Ω–∏–µ —Å—Ç–∏–∫–æ–≤ + –∫–Ω–æ–ø–æ–∫ —Å –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ (WebXR Gamepad)
            const session = renderer.xr.getSession();
            if (session && dt > 0) {
                const gpR = getGamepad(session, 'right');
                const gpL = getGamepad(session, 'left');

                // –æ–±—â–∏–π edge-detect —Å—Ç–æ—Ä
                if (!animate._prev) animate._prev = { a: false, b: false, x: false, y: false };

                // –ü—Ä–∞–≤—ã–π —Å—Ç–∏–∫: X ‚Äî —Å–º–µ—â–µ–Ω–∏–µ; Y ‚Äî –¥–∏—Å—Ç–∞–Ω—Ü–∏—è
                if (gpR) {
                    const axes = gpR.axes || [];
                    let stickX = 0;
                    let stickY = 0;
                    if (axes.length >= 4) {
                        stickX = axes[2];
                        stickY = axes[3];
                    } else if (axes.length >= 2) {
                        stickX = axes[0];
                        stickY = axes[1];
                    }

                    stickX = deadzone(stickX, 0.12);
                    stickY = deadzone(stickY, 0.12);

                    disparityX = clamp(disparityX + stickX * 0.60 * dt, -0.6, 0.6);
                    targetDistance = clamp(targetDistance - stickY * 0.90 * dt, 0.6, 4.0);

                    // –ö–Ω–æ–ø–∫–∏ (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ Oculus Touch)
                    // 4: A ‚Äî –ø—É–ª—å—Å–∞—Ü–∏—è on/off
                    // 5: B ‚Äî —Å–º–µ–Ω–∞ –ø–µ—Ä–∏–æ–¥–∞ –ø—É–ª—å—Å–∞—Ü–∏–∏
                    const pressedA = buttonPressed(gpR, 4);
                    const pressedB = buttonPressed(gpR, 5);
                    if (pressedA && !animate._prev.a) {
                        pulseEnabled = !pulseEnabled;
                    }
                    if (pressedB && !animate._prev.b) {
                        pulsePeriodIndex = (pulsePeriodIndex + 1) % PULSE_PERIODS.length;
                    }
                    animate._prev.a = pressedA;
                    animate._prev.b = pressedB;
                }

                // –õ–µ–≤—ã–π —Å—Ç–∏–∫: Y ‚Äî –≤—ã—Å–æ—Ç–∞ (—Å–∏–¥—è/—Å—Ç–æ—è)
                if (gpL) {
                    const axes = gpL.axes || [];
                    let stickY = 0;
                    if (axes.length >= 4) stickY = axes[3];
                    else if (axes.length >= 2) stickY = axes[1];
                    stickY = deadzone(stickY, 0.12);
                    targetHeight = clamp(targetHeight - stickY * 0.90 * dt, 0.7, 2.2);

                    // X/Y –Ω–∞ –ª–µ–≤–æ–º –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ: —Ä–µ–∂–∏–º / —Ñ–∏–≥—É—Ä–∞ split
                    const pressedX = buttonPressed(gpL, 4);
                    const pressedY = buttonPressed(gpL, 5);

                    if (pressedX && !animate._prev.x) {
                        modeIndex = (modeIndex + 1) % MODES.length;
                        applyModeVisibility();
                    }
                    if (pressedY && !animate._prev.y) {
                        splitShapeIndex = (splitShapeIndex + 1) % SPLIT_SHAPES.length;
                        applyModeVisibility();
                    }

                    animate._prev.x = pressedX;
                    animate._prev.y = pressedY;
                }
            }

            // –ü—É–ª—å—Å–∞—Ü–∏—è (–ø–æ –æ—á–µ—Ä–µ–¥–∏ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≥–ª–∞–∑–∞)
            const period = pulsePeriodSeconds();
            const halfPeriod = period / 2;
            const tSec = time / 1000;
            const phaseIndex = pulseEnabled ? (Math.floor(tSec / halfPeriod) % 2) : -1;
            const localT = pulseEnabled ? ((tSec % halfPeriod) / halfPeriod) : 0;
            // –†–µ–∑–∫–æ–µ –ø–∞–¥–µ–Ω–∏–µ –≤ –Ω–∞—á–∞–ª–µ + –ø–ª–∞–≤–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
            const pulseAlpha = pulseEnabled ? (0.05 + 0.95 * easeOutCubic(localT)) : 1.0;
            const leftOpacity = !pulseEnabled ? 1.0 : (phaseIndex === 0 ? pulseAlpha : 1.0);
            const rightOpacity = !pulseEnabled ? 1.0 : (phaseIndex === 1 ? pulseAlpha : 1.0);

            const setOpacity = (mesh, on) => {
                if (!mesh || !mesh.material) return;
                mesh.material.opacity = on ? 1.0 : 0.15;
                mesh.material.transparent = true;
                mesh.material.needsUpdate = true;
            };

            const setOpacityValue = (mesh, opacity) => {
                if (!mesh || !mesh.material) return;
                mesh.material.opacity = opacity;
                mesh.material.transparent = opacity < 1.0;
                mesh.material.needsUpdate = true;
            };

            setOpacityValue(leftRing, leftOpacity);
            setOpacityValue(leftHalfDisk, leftOpacity);
            setOpacityValue(leftZigSplit, leftOpacity);
            setOpacityValue(rightDot, rightOpacity);
            setOpacityValue(rightGuideRing, rightOpacity);
            setOpacityValue(rightHalfDisk, rightOpacity);
            setOpacityValue(rightZigSplit, rightOpacity);

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ —Å—Ç–∏–º—É–ª–æ–≤
            if (stimulusGroup) stimulusGroup.position.set(0, targetHeight, -targetDistance);

            // –°–º–µ—â–µ–Ω–∏–µ –ø–æ X (–¥–∏—Å–ø–∞—Ä–∞—Ç–Ω–æ—Å—Ç—å)
            if (leftRing) leftRing.position.set(-disparityX / 2, 0, 0);
            if (leftHalfDisk) leftHalfDisk.position.set(-disparityX / 2, 0, 0);
            if (leftZigSplit) leftZigSplit.position.set(-disparityX / 2, 0, 0);
            if (rightDot) rightDot.position.set(disparityX / 2, 0, 0);
            if (rightGuideRing) rightGuideRing.position.set(disparityX / 2, 0, 0);
            if (rightHalfDisk) rightHalfDisk.position.set(disparityX / 2, 0, 0);
            if (rightZigSplit) rightZigSplit.position.set(disparityX / 2, 0, 0);

            // HUD –æ–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–¥–∫–æ (–±–µ–∑ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä)
            const nowMs = performance.now();
            const alignedNow = Math.abs(disparityX) <= tolerance;

            // –ö–æ–≥–¥–∞ —Å–æ–≤–ø–∞–ª–æ ‚Äî —É–±–∏—Ä–∞–µ–º ¬´—Ç–µ–Ω–µ–≤–æ–µ¬ª –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–µ–µ –∫–æ–ª—å—Ü–æ, —á—Ç–æ–±—ã —Ü–µ–Ω—Ç—Ä+–∫–æ–ª—å—Ü–æ —Å–ª–∏–≤–∞–ª–∏—Å—å
            const modeNow = currentMode();
            if (rightGuideRing) rightGuideRing.visible = modeNow === 'alignment' && !alignedNow;

            if (hudPanel && nowMs - hudLastUpdateAtMs > 250) {
                const mode = modeNow;
                const shape = currentSplitShape();
                const pulse = pulseEnabled ? `ON (${period.toFixed(1)}s)` : 'OFF';
                const hint = alignedNow ? '–°–û–í–ü–ê–õ–û ‚úÖ  –ù–∞–∂–º–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä' : '–°–æ–≤–º–µ—Å—Ç–∏—Ç–µ –∏ –Ω–∞–∂–º–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä';
                const txt =
                    `–†–µ–∂–∏–º: ${mode} (X)   |   Split-—Ñ–∏–≥—É—Ä–∞: ${shape} (Y)\n` +
                    `–ü—É–ª—å—Å–∞—Ü–∏—è: ${pulse} (A/B)\n` +
                    `–ü—Ä–∞–≤—ã–π —Å—Ç–∏–∫: —Å–º–µ—â–µ–Ω–∏–µ/–¥–∏—Å—Ç–∞–Ω—Ü–∏—è   –õ–µ–≤—ã–π —Å—Ç–∏–∫: –≤—ã—Å–æ—Ç–∞\n` +
                    `Dist: ${targetDistance.toFixed(2)}m  Height: ${targetHeight.toFixed(2)}m  |dx|: ${Math.abs(disparityX).toFixed(3)}m\n` +
                    `–°—á—ë—Ç: ${score}/${trials}   |   ${hint}`;
                updateHudPanel(hudPanel, txt, alignedNow ? '#1f7a3a' : '#222222');
                hudLastUpdateAtMs = nowMs;
            }

            // –í WebXR three.js —Å–∞–º —Ä–∏—Å—É–µ—Ç –æ–±–∞ –≥–ª–∞–∑–∞ –∑–∞ –æ–¥–∏–Ω render().
            // –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø–æ –≥–ª–∞–∑–∞–º –¥–µ–ª–∞–µ–º —á–µ—Ä–µ–∑ layers.
            const xrCamera = renderer.xr.getCamera(camera);
            if (xrCamera && xrCamera.isArrayCamera && xrCamera.cameras && xrCamera.cameras.length >= 2) {
                // –û–±—â–∏–π —Å–ª–æ–π 0: –ø–æ–ª/—Å–µ—Ç–∫–∞ –∏ —Ç.–ø.
                // –õ–µ–≤—ã–π –≥–ª–∞–∑: —Å–ª–æ–π 1, –ü—Ä–∞–≤—ã–π –≥–ª–∞–∑: —Å–ª–æ–π 2
                xrCamera.cameras[0].layers.enable(0);
                xrCamera.cameras[0].layers.enable(1);
                xrCamera.cameras[0].layers.disable(2);

                xrCamera.cameras[1].layers.enable(0);
                xrCamera.cameras[1].layers.enable(2);
                xrCamera.cameras[1].layers.disable(1);

                if (frameCount % 120 === 0) {
                    console.log(`XR cameras: ${xrCamera.cameras.length} (layers L=${xrCamera.cameras[0].layers.mask} R=${xrCamera.cameras[1].layers.mask})`);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>