<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Stereo Rendering</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 90%;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        h1 {
            margin: 0 0 15px 0;
            font-size: 1.8em;
        }
        
        p {
            margin: 0 0 25px 0;
            opacity: 0.9;
            line-height: 1.5;
        }
        
        button {
            background: white;
            color: #667eea;
            border: none;
            padding: 18px 45px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 20px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            font-size: 15px;
        }
        
        .version {
            margin-top: 15px;
            font-size: 12px;
            opacity: 0.7;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ü•Ω –ë–∏–Ω–æ–∫—É–ª—è—Ä–Ω—ã–π MVP</h1>
        <p>
            –¢—Ä–µ–Ω–∞–∂—ë—Ä ¬´–°–æ–≤–º–µ—Å—Ç–∏ —Ç–æ—á–∫–∏¬ª (dichoptic alignment)<br>
            –°—Ç–∏–∫: –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ ‚Äî —Å–º–µ—â–µ–Ω–∏–µ, –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑ ‚Äî –¥–∏—Å—Ç–∞–Ω—Ü–∏—è<br>
            –¢—Ä–∏–≥–≥–µ—Ä: –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å
        </p>
        <button id="startBtn" onclick="startXR()">–ó–∞–ø—É—Å—Ç–∏—Ç—å VR</button>
        <div id="status">–ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø—É—Å–∫—É</div>
        <div class="version">v0.1 - MVP alignment</div>
    </div>
    
    <canvas id="glCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let leftMarker, rightMarker;
        let hudInfoSprite, hudFeedbackSprite;
        let crosshair;
        let xrSession = null;
        let frameCount = 0;
        let debugInfo = { leftEye: 'unknown', rightEye: 'unknown', viewCount: 0 };

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞
        let targetDistance = 2.0; // –º–µ—Ç—Ä—ã –¥–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Å—Ç–∏–º—É–ª–æ–≤
        let disparityX = 0.25; // —Ç–µ–∫—É—â–µ–µ —Å–º–µ—â–µ–Ω–∏–µ (–º)
        let tolerance = 0.015; // –ø–æ—Ä–æ–≥ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è (–º)
        let score = 0;
        let trials = 0;
        let lastTimeMs = 0;
        let lastSelectAtMs = -1e9;
        
        const canvas = document.getElementById('glCanvas');
        const startBtn = document.getElementById('startBtn');
        const statusDiv = document.getElementById('status');
        const container = document.getElementById('container');
        
        function log(msg) {
            console.log(msg);
            statusDiv.textContent = msg;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ WebXR
        if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                if (supported) {
                    log('‚úÖ WebXR –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                } else {
                    log('‚ùå VR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                    startBtn.disabled = true;
                }
            }).catch(err => {
                log('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: ' + err.message);
                startBtn.disabled = true;
            });
        } else {
            log('‚ùå WebXR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
            startBtn.disabled = true;
        }
        
        function createTextTexture(message, backgroundColor) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;

            const lines = String(message).split(/\r?\n/);

            // –§–æ–Ω
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);

            // –ö–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ã–π —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ (–µ—Å–ª–∏ —Ñ–æ–Ω –±–µ–ª—ã–π ‚Äî —Ä–∏—Å—É–µ–º —á—ë—Ä–Ω—ã–º)
            const bg = String(backgroundColor).toLowerCase();
            const textColor = (bg === '#fff' || bg === '#ffffff' || bg === 'white') ? '#000000' : '#ffffff';

            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = textColor;

            // –ü–æ–¥–±–∏—Ä–∞–µ–º —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞, —á—Ç–æ–±—ã –≤–ª–µ–∑–ª–∞ —Å–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
            const maxTextWidth = canvas.width - 40;
            let fontSize = 64;
            while (fontSize >= 22) {
                context.font = `Bold ${fontSize}px Arial`;
                const widest = lines.reduce((m, line) => Math.max(m, context.measureText(line).width), 0);
                if (widest <= maxTextWidth) break;
                fontSize -= 2;
            }

            const lineHeight = Math.round(fontSize * 1.1);
            const totalHeight = lineHeight * lines.length;
            const startY = (canvas.height - totalHeight) / 2 + lineHeight / 2;

            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –≤ 3D (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞)
        function createTextSprite(message, backgroundColor) {
            const texture = createTextTexture(message, backgroundColor);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2, 1, 1);
            return sprite;
        }

        function updateTextSprite(sprite, message, backgroundColor) {
            if (!sprite || !sprite.material) return;
            const oldMap = sprite.material.map;
            sprite.material.map = createTextTexture(message, backgroundColor);
            sprite.material.needsUpdate = true;
            if (oldMap) oldMap.dispose();
        }

        function clamp(v, min, max) {
            return Math.min(max, Math.max(min, v));
        }

        function deadzone(v, dz) {
            return Math.abs(v) < dz ? 0 : v;
        }

        function randomizeTrial() {
            const mag = 0.08 + Math.random() * 0.30;
            const sign = Math.random() < 0.5 ? -1 : 1;
            disparityX = mag * sign;
            trials++;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
        function initThreeJS() {
            log('üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js...');
            
            // –°—Ü–µ–Ω–∞
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // –ö–∞–º–µ—Ä–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 0);
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(2, 3, 2);
            scene.add(light1);

            // –ö—Ä–µ—Å—Ç —Ñ–∏–∫—Å–∞—Ü–∏–∏ (–≤–∏–¥–µ–Ω –æ–±–æ–∏–º–∏ –≥–ª–∞–∑–∞–º–∏)
            crosshair = new THREE.Group();
            crosshair.layers.set(0);
            const chMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const chH = new THREE.Mesh(new THREE.BoxGeometry(0.20, 0.01, 0.01), chMat);
            const chV = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.20, 0.01), chMat);
            crosshair.add(chH);
            crosshair.add(chV);
            crosshair.position.set(0, 1.6, -targetDistance);
            scene.add(crosshair);

            // –ú–∞—Ä–∫–µ—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –≥–ª–∞–∑
            const markerGeom = new THREE.SphereGeometry(0.035, 24, 24);
            const leftMat = new THREE.MeshStandardMaterial({ color: 0xff4d4d, emissive: 0xff0000, emissiveIntensity: 0.4 });
            const rightMat = new THREE.MeshStandardMaterial({ color: 0x4d7dff, emissive: 0x0000ff, emissiveIntensity: 0.4 });

            leftMarker = new THREE.Mesh(markerGeom, leftMat);
            leftMarker.layers.set(1); // –ª–µ–≤—ã–π –≥–ª–∞–∑
            leftMarker.position.set(-disparityX / 2, 1.6, -targetDistance);
            scene.add(leftMarker);

            rightMarker = new THREE.Mesh(markerGeom, rightMat);
            rightMarker.layers.set(2); // –ø—Ä–∞–≤—ã–π –≥–ª–∞–∑
            rightMarker.position.set(disparityX / 2, 1.6, -targetDistance);
            scene.add(rightMarker);

            // HUD –≤ VR (–≤–∏–¥–µ–Ω –æ–±–æ–∏–º–∏ –≥–ª–∞–∑–∞–º–∏)
            hudInfoSprite = createTextSprite('–°—Ç–∏–∫: X=—Å–º–µ—â–µ–Ω–∏–µ, Y=–¥–∏—Å—Ç–∞–Ω—Ü–∏—è\n–¢—Ä–∏–≥–≥–µ—Ä: –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', '#222222');
            hudInfoSprite.position.set(0, 2.55, -1.7);
            hudInfoSprite.scale.set(3.2, 1.2, 1);
            hudInfoSprite.layers.set(1);
            hudInfoSprite.layers.enable(2);
            scene.add(hudInfoSprite);

            hudFeedbackSprite = createTextSprite('...', '#222222');
            hudFeedbackSprite.position.set(0, 2.15, -1.7);
            hudFeedbackSprite.scale.set(2.6, 0.9, 1);
            hudFeedbackSprite.layers.set(1);
            hudFeedbackSprite.layers.enable(2);
            scene.add(hudFeedbackSprite);
            
            // –ü–æ–ª
            const floorGeom = new THREE.PlaneGeometry(10, 10);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeom, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);
            
            // –°–µ—Ç–∫–∞
            const grid = new THREE.GridHelper(10, 20, 0x666666, 0x444444);
            grid.position.y = 0.01;
            scene.add(grid);

            // –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã: —Ç—Ä–∏–≥–≥–µ—Ä (select) –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            const controller0 = renderer.xr.getController(0);
            const controller1 = renderer.xr.getController(1);
            const onSelect = () => {
                const now = performance.now();
                // –∞–Ω—Ç–∏–¥—Ä–µ–±–µ–∑–≥
                if (now - lastSelectAtMs < 250) return;
                lastSelectAtMs = now;

                const aligned = Math.abs(disparityX) <= tolerance;
                if (aligned) score++;
                updateTextSprite(
                    hudFeedbackSprite,
                    aligned ? 'OK ‚úÖ\n–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥' : '–ù–µ —Å–æ–≤–ø–∞–ª–æ ‚ùå\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë',
                    aligned ? '#1f7a3a' : '#7a1f1f'
                );

                // –Ω–æ–≤—ã–π —Ä–∞—É–Ω–¥ (–∏ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ, –∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî —á—Ç–æ–±—ã –±—ã–ª–æ –¥–≤–∏–∂–µ–Ω–∏–µ)
                randomizeTrial();
            };
            controller0.addEventListener('selectstart', onSelect);
            controller1.addEventListener('selectstart', onSelect);
            scene.add(controller0);
            scene.add(controller1);

            randomizeTrial();
            
            log('‚úÖ Three.js –≥–æ—Ç–æ–≤');
        }
        
        // –ó–∞–ø—É—Å–∫ XR
        async function startXR() {
            try {
                log('üöÄ –ó–∞–ø—É—Å–∫ VR...');
                startBtn.disabled = true;
                
                initThreeJS();
                
                xrSession = await navigator.xr.requestSession('immersive-vr', {
                    requiredFeatures: ['local-floor']
                });
                
                log('‚úÖ –°–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞');
                
                await renderer.xr.setSession(xrSession);
                
                container.style.display = 'none';
                
                log('‚úÖ VR –∞–∫—Ç–∏–≤–µ–Ω!');
                
                xrSession.addEventListener('end', () => {
                    log('VR –∑–∞–≤–µ—Ä—à—ë–Ω');
                    container.style.display = 'block';
                    startBtn.disabled = false;
                    xrSession = null;
                    frameCount = 0;
                });
                
                renderer.setAnimationLoop(animate);
                
            } catch (err) {
                log('‚ùå –û—à–∏–±–∫–∞: ' + err.message);
                console.error(err);
                startBtn.disabled = false;
            }
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥
        function animate(time) {
            frameCount++;

            const dt = lastTimeMs ? (time - lastTimeMs) / 1000 : 0;
            lastTimeMs = time;

            // –í—Ä–∞—â–∞–µ–º –º–∞—Ä–∫–µ—Ä—ã —Å–ª–µ–≥–∫–∞, —á—Ç–æ–±—ã –±—ã–ª–∏ "–∂–∏–≤—ã–º–∏"
            if (leftMarker) {
                leftMarker.rotation.y = time * 0.001;
                leftMarker.rotation.x = time * 0.0005;
            }
            if (rightMarker) {
                rightMarker.rotation.y = time * 0.001;
            }

            // –ß—Ç–µ–Ω–∏–µ —Å—Ç–∏–∫–∞ —Å –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ (WebXR Gamepad)
            const session = renderer.xr.getSession();
            if (session && dt > 0) {
                let stickX = 0;
                let stickY = 0;

                for (const src of session.inputSources) {
                    if (!src || !src.gamepad) continue;
                    // –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –ø—Ä–∞–≤—ã–π, –Ω–æ –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –±–µ—Ä—ë–º –ª—é–±–æ–π
                    if (src.handedness && src.handedness !== 'right' && src.handedness !== 'none') continue;

                    const axes = src.gamepad.axes || [];
                    // Oculus Touch –æ–±—ã—á–Ω–æ: axes[2]=x, axes[3]=y; –Ω–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –∏ [0],[1]
                    if (axes.length >= 4) {
                        stickX = axes[2];
                        stickY = axes[3];
                    } else if (axes.length >= 2) {
                        stickX = axes[0];
                        stickY = axes[1];
                    }
                    break;
                }

                stickX = deadzone(stickX, 0.12);
                stickY = deadzone(stickY, 0.12);

                // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: X ‚Äî —Å–º–µ—â–µ–Ω–∏–µ; Y ‚Äî –¥–∏—Å—Ç–∞–Ω—Ü–∏—è (–≤–≤–µ—Ä—Ö = –±–ª–∏–∂–µ)
                disparityX = clamp(disparityX + stickX * 0.60 * dt, -0.6, 0.6);
                targetDistance = clamp(targetDistance - stickY * 0.90 * dt, 0.6, 4.0);
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ —Å—Ç–∏–º—É–ª–æ–≤
            if (crosshair) crosshair.position.set(0, 1.6, -targetDistance);
            if (leftMarker) leftMarker.position.set(-disparityX / 2, 1.6, -targetDistance);
            if (rightMarker) rightMarker.position.set(disparityX / 2, 1.6, -targetDistance);

            // –ñ–∏–≤–æ–π —Å—Ç–∞—Ç—É—Å
            const alignedNow = Math.abs(disparityX) <= tolerance;
            if (hudInfoSprite && frameCount % 10 === 0) {
                updateTextSprite(
                    hudInfoSprite,
                    `–°—Ç–∏–∫: X=—Å–º–µ—â–µ–Ω–∏–µ, Y=–¥–∏—Å—Ç–∞–Ω—Ü–∏—è\n–î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${targetDistance.toFixed(2)} –º  |  |—Å–º–µ—â–µ–Ω–∏–µ|: ${Math.abs(disparityX).toFixed(3)} –º\n–°—á—ë—Ç: ${score}/${trials}`,
                    '#222222'
                );
            }
            if (hudFeedbackSprite && frameCount % 10 === 0) {
                updateTextSprite(
                    hudFeedbackSprite,
                    alignedNow ? '–°–ï–ô–ß–ê–° –°–û–í–ü–ê–õ–û ‚úÖ\n–ù–∞–∂–º–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä' : '–°–æ–≤–º–µ—Å—Ç–∏—Ç–µ —Ç–æ—á–∫–∏\n–∏ –Ω–∞–∂–º–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä',
                    alignedNow ? '#1f7a3a' : '#222222'
                );
            }

            // –í WebXR three.js —Å–∞–º —Ä–∏—Å—É–µ—Ç –æ–±–∞ –≥–ª–∞–∑–∞ –∑–∞ –æ–¥–∏–Ω render().
            // –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø–æ –≥–ª–∞–∑–∞–º –¥–µ–ª–∞–µ–º —á–µ—Ä–µ–∑ layers.
            const xrCamera = renderer.xr.getCamera(camera);
            if (xrCamera && xrCamera.isArrayCamera && xrCamera.cameras && xrCamera.cameras.length >= 2) {
                // –û–±—â–∏–π —Å–ª–æ–π 0: –ø–æ–ª/—Å–µ—Ç–∫–∞ –∏ —Ç.–ø.
                // –õ–µ–≤—ã–π –≥–ª–∞–∑: —Å–ª–æ–π 1, –ü—Ä–∞–≤—ã–π –≥–ª–∞–∑: —Å–ª–æ–π 2
                xrCamera.cameras[0].layers.enable(0);
                xrCamera.cameras[0].layers.enable(1);
                xrCamera.cameras[0].layers.disable(2);

                xrCamera.cameras[1].layers.enable(0);
                xrCamera.cameras[1].layers.enable(2);
                xrCamera.cameras[1].layers.disable(1);

                if (frameCount % 120 === 0) {
                    console.log(`XR cameras: ${xrCamera.cameras.length} (layers L=${xrCamera.cameras[0].layers.mask} R=${xrCamera.cameras[1].layers.mask})`);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
